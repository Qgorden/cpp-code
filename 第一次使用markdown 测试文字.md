第一次使用markdown 测试文字
两天完成了fileread.c 和filewirte.c
（1）完成了github的注册，过程期间很顺利，建立库很顺利
（2）vscode 的配置时花费了很多时间，因为使用的是mac版本，所以能参考的东西很少，花了很多时间来配置launch.json settings.json tasks.json尤其是里面的路径配置
（3）第一次编写工程，分别写了filteread/filewirte，实现了读取user_login.txt文件用了fopen函数，并且成功用链表存储了用户名称，由于数量过大使用了strcpy函数。
在运行main.exe程序
查找了很多资料
最终在//
【链接】知乎用户
https://www.zhihu.com/question/358453199
//
这个链接里找到了答案，用了工程makefile 的命令行./main.exe形成了result。txt文件并且成功。
gcc main.c fileread.c filewirte.c List.c -o main.exe这个生成了main。exe
//********typora能够编写但是picgo上传老显示服务器错误，明天继续研究一下
(4)list的创建，销毁，删除添加节点，遍历和之前上课学的没什么区别，节点合并要麻烦一点
（5）冒泡排序：重复走访要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小，首字母a到z）错误就把他们交换过来，走访元素的工作就是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。具体原理很熟悉，调试了4，5次就成功了。指针的运行比较复杂麻烦，细节要处理的很好才行，很细致，整体没有陌生的问题。
（6）快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行。
（7）堆排序：利用堆来进行储存和设计，近似完全二叉树，子结点的键值或索引总是小于（或大于）父节点，堆的最大值总是位于根结点。步骤一：最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点。步骤二：创造最大堆，并将堆中的所有数据重新排序。步骤三：堆排序，移除位在第一个数据的根结点，并做最大堆调整的递归运算。
（8）基排序：将要排序的元素分配至某些桶中。
（9）经过调试，成功完成了两个步骤的要求
对于额外的要求也有一定的想法：
(1)这个只需要在统计的时候把月份也统计进去就行了，然后每个人每个月作为一个链表节点即可
(2)这个涉及到多种因素，关于统计，如果我们用链表存储，每次都要遍历链表，如果我们用数组存储，使用hash表判断当前字段是否出现过，那么这个统计的时间复杂度为O(n)；关于排序，根据统计完成的数据量我们可以选择基数排序或者快速排序，快速排序的时间复杂度为O(nlogn)，基数排序的时间复杂度为O(dn),那么我们只需要根据d和logn的大小关系进行选取即可，那么最后整个过程的时间复杂度为O(n+min(nlogn,dn))